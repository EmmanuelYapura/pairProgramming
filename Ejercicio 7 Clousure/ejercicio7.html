<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ejercicio 7 - Pair Programming</title>
    <style>
        h2 { color: blue;}
        h2 pre { color: purple;}
    </style>
</head>

<body>
    <h2>
        <u>Ejercicio 1</u>
        <pre>
        La funcion contador debe retornar una funcion que cuando sea invocada retorne un valor creciente.
        el primer valor deberia ser 1.
        Sugerencia: usar closures.

        Ejemplo: 
        const newCounter = counter();
        newCounter(); // 1
        newCounter(); // 2        
        </pre>
    </h2>
    <hr>

    <!-- ------------------------------------------------------------------------------------------------------- -->
    <h2>
        <u>Ejercicio 2</u>
        <pre>
        Usar closures para crear un cache para la funcion cb.
        La funcion que retornas debe aceptar un solo argumento e invocar a cb con ese argumento
        Cuando la funcion que hayas retornado es invocada de nuevo, deberia guardar el argumento y el resultado de la invocacion.
        Cuando la funcion que retornaste sea invocada de nuevo con un argumento con el cual se habia invocado anterioremente,
        no deberia invocar de nuevo a cb deberia retornar el resultado (previamente guardado)

        Ejemplo:
        cb -> function(x) { return x * x; }
        si invocas la function que retornaste con 5, adentro deberia invocar cb(5) y retornar 25.
        si la invocas de nuevo con 5, deberia retornar 25 (guardado previament en el cache).
        Nota: usá un objeto donde cada propiedad sea un argumento, y el valor el resultado.
            usá hasOwnProperty!       
        </pre>
    </h2>
    <hr>
   
    <script src="js/main.js"></script>

</body>

</html>